---
layout: post
title:  "Distinct Substrings of String  from O(n^3) to O(nlogn)"
date:   2020-08-28 21:28:15 +0700
tag: [DS,Algo]

---

## First Approach- *BRUTE FORCE*
### Complexity *O(n^2(n+logn))*

The first approach which comes to mind is brute force .In this approach we are using a set to store all the distinct substrings.
We can convert this complexity to n^3 by using an array instead of a set .(Insert operation in set is causing the  logn factor)

```
string str;
	cin>>str;
	int n=str.length();
	set<string>st;
	for(int len=1;len<=n;len++)
	{
		for(int l=0;l<=n-len;l++)
		{
			int r=len+l-1;
			string s=str.substr(l,len);
			st.insert(s);
			
		}
	}
	cout<<st.size()<<endl;
```

## Second Approach-*KNUTH-MORRIS-PRATT ALGORITHM*

### Complexity *O(n^2)*

We will solve this problem iteratively. Namely we will learn, knowing the current number of different substrings, how to recompute this count by adding a character to the end.

So let k be the current number of different substrings in s, and we add the character c to the end of s. Obviously some new substrings ending in c will appear. We want to count these new substrings that didn't appear before.

We take the string t=s+c and reverse it. Now the task is transformed into computing how many prefixes there are that don't appear anywhere else. If we compute the maximal value of the prefix function πmax of the reversed string t, then the longest prefix that appears in s is πmax long. Clearly also all prefixes of smaller length appear in it.

Therefore the number of new substrings appearing when we add a new character c is |s|+1−π(max).

So for each character appended we can compute the number of new substrings in O(n) times, which gives a time complexity of O(n2) in total.

```
vector<int> prefix_function(string s) {
    int n = (int)s.length();
    vector<int> pi(n);
    for (int i = 1; i < n; i++) {
        int j = pi[i-1];
        while (j > 0 && s[i] != s[j])
            j = pi[j-1];
        if (s[i] == s[j])
            j++;
        pi[i] = j;
    }
    return pi;
}
string str;
	cin>>str;
	int n=str.length();
	int ans=0; 
	string sub=str.substr(0,1);
	ans++;//for string of length 1
	for(int i=1;i<n;i++)
	{
		sub+=str[i];
		reverse(sub.begin(),sub.end());
		vector<int>pi=prefix_function(sub);
		int mx=*max_element(pi.begin(),pi.end());
		reverse(sub.begin(),sub.end());
		ans+=i+1-mx;
	}
	cout<<ans<<endl;
	
```

## Third Approach- *USING SUFFIX TRIES*
### Complexity- *O(n^2)*

The idea is create a Trie of all suffixes of given string. Once the Trie is constricted, our answer is total number of nodes in the constructed Trie.

```
int ans;
const int sigma=26;
typedef struct node
{
	node *next[sigma];
	int wend;
	int prefix;
	node()
	{
		wend=0;
		prefix=0;
		for(int i=0;i<sigma;i++)
			next[i]=NULL;
	}
}trie;
trie *head;
void insert(string &s)
{
	trie *cur=head;
	for(int i=0;i<s.length();i++)
	{
		if(cur->next[s[i]-'a']==NULL)
		{
			cur->next[s[i]-'a']=new trie();
			ans++;
			
		}
		cur=cur->next[s[i]-'a'];
		cur->prefix++;
		

	}
	cur->wend++;
	
}
string str;
	cin>>str;
	int n=str.length();
	head =new trie();
	ans=0;
	string sub=str.substr(n-1,1);
	insert(sub);
	for(int i=n-2;i>=0;i--)
	{
		sub=str[i]+sub;
		insert(sub);

	}
	cout<<ans<<endl;
	
```

## Fourth Approach- *USING SUFFIX ARRAYS*
### Complexity -*O(nlogn)* 

This is the most optimised approach of finding the number of distinct substrings.












